<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="dongkw"><meta name="copyright" content="dongkw"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>redis | Hexo</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.19/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/dongkw.github.io/yun.svg"><link rel="mask-icon" href="/dongkw.github.io/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/dongkw.github.io/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/dongkw.github.io/js/utils.js" as="script"><link rel="preload" href="/dongkw.github.io/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/dongkw.github.io/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/dongkw.github.io/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/dongkw.github.io/","title":"克威的小小地盘","version":"1.0.0","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="[redis知识点]https:&#x2F;&#x2F;www.processon.com&#x2F;view&#x2F;link&#x2F;5ef981b9f346fb1ae5831bdc Redis 基础数据结构Redis 所有数据结构都是以唯一的key字符串作为名称，通过key获取value数据，不同类型的区别是value结构不一样。">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://dongkw.github.io/2020/03/20/redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[redis知识点]https:&#x2F;&#x2F;www.processon.com&#x2F;view&#x2F;link&#x2F;5ef981b9f346fb1ae5831bdc Redis 基础数据结构Redis 所有数据结构都是以唯一的key字符串作为名称，通过key获取value数据，不同类型的区别是value结构不一样。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://dongkw.github.io/images/redisstring.svg">
<meta property="og:image" content="http://dongkw.github.io/images/bloom.svg">
<meta property="og:image" content="http://dongkw.github.io/images/103.png">
<meta property="og:image" content="http://dongkw.github.io/images/104.png">
<meta property="og:image" content="http://dongkw.github.io/images/105.png">
<meta property="article:published_time" content="2020-03-19T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-22T01:34:52.892Z">
<meta property="article:author" content="dongkw">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://dongkw.github.io/images/redisstring.svg"><script src="/dongkw.github.io/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/dongkw.github.io/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/dongkw.github.io/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/dongkw.github.io/about/" title="dongkw"><img width="96" loading="lazy" src="/dongkw.github.io/images/avatar.jpeg" alt="dongkw"></a><div class="site-author-name"><a href="/dongkw.github.io/about/">dongkw</a></div><a class="site-name" href="/dongkw.github.io/about/site.html">Hexo</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/dongkw.github.io/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/dongkw.github.io/archives" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">27</span></a></div><div class="site-state-item"><a href="/dongkw.github.io/categories" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">16</span></a></div><div class="site-state-item"><a href="/dongkw.github.io/tags" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">23</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://github.com/dongkw" title="git"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/dongkw.github.io/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Redis 基础数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">string（字符串）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8dict"><span class="toc-number">1.2.</span> <span class="toc-text">字典dict</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list-%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">list （列表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.1.</span> <span class="toc-text">慢操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">快速列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash-%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">hash （哈希）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">set （集合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zset-%EF%BC%88%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">zset （有序列表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">跳跃列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">容器型数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">redis 可以用来解决什么问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">redis 分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">redis 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.2.1.</span> <span class="toc-text">异步消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">延时队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">位图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">2.4.</span> <span class="toc-text">HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">HyperLogLog实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8Bloom-Filter"><span class="toc-number">2.5.</span> <span class="toc-text">布隆过滤器Bloom Filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%99%90%E6%B5%81"><span class="toc-number">2.6.</span> <span class="toc-text">简单限流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%96%97%E9%99%90%E6%B5%81-redis-cell"><span class="toc-number">2.7.</span> <span class="toc-text">漏斗限流 redis-cell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GeoHash-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E6%8E%92%E5%BA%8F"><span class="toc-number">2.8.</span> <span class="toc-text">GeoHash 地理位置排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scan-%E6%89%BE%E5%87%BA%E7%89%B9%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84key%E5%88%97%E8%A1%A8"><span class="toc-number">2.9.</span> <span class="toc-text">Scan 找出特定前缀的key列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.9.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%A4%A7key"><span class="toc-number">2.9.2.</span> <span class="toc-text">避免使用大key</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%A4%A7key"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">定位大key</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">redis IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIO"><span class="toc-number">3.1.</span> <span class="toc-text">什么是IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">3.2.</span> <span class="toc-text">非阻塞IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">事件轮询 (多路复用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%98%9F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">指令队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%98%9F%E5%88%97"><span class="toc-number">3.5.</span> <span class="toc-text">响应队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.6.</span> <span class="toc-text">定时任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">Redis通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RESP-Redis-Serialization-Protocol-Redis%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">RESP(Redis Serialization Protocol)Redis序列化协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-gt-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">客户端-&gt;服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8-gt-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.3.</span> <span class="toc-text">服务器-&gt;客户端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7-%E4%B8%80%E6%AC%A1%E6%80%A7%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD"><span class="toc-number">5.1.</span> <span class="toc-text">快照 一次性全量备份</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99-%E8%BF%9E%E7%BB%AD%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD"><span class="toc-number">5.2.</span> <span class="toc-text">AOF重写 连续增量备份</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4"><span class="toc-number">5.3.</span> <span class="toc-text">运维</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text">混合持久化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%AE%A1%E9%81%93"><span class="toc-number">6.</span> <span class="toc-text">Redis管道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.</span> <span class="toc-text">redis事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%8E%8B%E7%BC%A9"><span class="toc-number">8.</span> <span class="toc-text">redis 小对象压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8-ziplist"><span class="toc-number">8.1.</span> <span class="toc-text">小对象压缩存储 ziplist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.</span> <span class="toc-text">redis的内存回收机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">9.</span> <span class="toc-text">redis主从同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cap%E5%8E%9F%E5%88%99"><span class="toc-number">9.1.</span> <span class="toc-text">cap原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">9.2.</span> <span class="toc-text">最终一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">9.3.</span> <span class="toc-text">主从同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">9.4.</span> <span class="toc-text">增量同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E5%90%8C%E6%AD%A5"><span class="toc-number">9.5.</span> <span class="toc-text">快照同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%9B%98%E5%A4%8D%E5%88%B6"><span class="toc-number">9.6.</span> <span class="toc-text">无盘复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait%E6%8C%87%E4%BB%A4"><span class="toc-number">9.7.</span> <span class="toc-text">wait指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5"><span class="toc-number">10.</span> <span class="toc-text">redis 集群策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-Sentinel-%E5%93%A8%E5%85%B5"><span class="toc-number">10.1.</span> <span class="toc-text">Redis Sentinel(哨兵)</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://dongkw.github.io/dongkw.github.io/2020/03/20/redis/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="dongkw"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">redis</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2020-09-22 09:34:52" itemprop="dateModified" datetime="2020-09-22T09:34:52+08:00">2020-09-22</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/dongkw.github.io/categories/redis/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">redis</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/dongkw.github.io/tags/redis/" style="--text-color:#F4DF4F"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">redis</span></a><a class="tag" href="/dongkw.github.io/tags/java/" style="--text-color:#0E83CD"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p>[redis知识点]<a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5ef981b9f346fb1ae5831bdc">https://www.processon.com/view/link/5ef981b9f346fb1ae5831bdc</a></p>
<h1 id="Redis-基础数据结构"><a href="#Redis-基础数据结构" class="headerlink" title="Redis 基础数据结构"></a>Redis 基础数据结构</h1><p>Redis 所有数据结构都是以唯一的key字符串作为名称，通过key获取value数据，不同类型的区别是value结构不一样。</p>
<a id="more"></a> 


<p>Redis有5种基础数据结构</p>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p><img src="/images/redisstring.svg" loading="lazy"></p>
<p>header和 SDS组成</p>
<p>header对象</p>
<ol>
<li>type 对象的类型 4byte</li>
<li>encoding 对象的编码格式 4byte</li>
<li>lru 记录当前项目的缓存淘汰算法 24byte</li>
<li>refcount 引用计数器 4byte</li>
<li>*ptr 指向内容 8byte</li>
</ol>
<p>SDS对象</p>
<ol>
<li>capacity 对象总空间 </li>
<li>len 对象已用空间 </li>
<li>flags 代表header对象类型 1byte</li>
<li>content 具体字符串信息 以”\0”结尾</li>
</ol>
<p>embstr 开始分配内存时header与sds相连<br>raw sds对象扩容 header通过#ptr指针指向扩容后的sds对象。</p>
<p>Redis 字符串是动态字符串，内部实现类似于Java的ArrayList，采用预分配冗余空间来减少内存频繁分配</p>
<p>分配方式 当字符串小于1M 每次加倍，大于1M 每次加1M 最大512M</p>
<h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><p>字典包括两个哈希表。</p>
<h2 id="list-（列表）"><a href="#list-（列表）" class="headerlink" title="list （列表）"></a>list （列表）</h2><p>Redis 的列表相当于java的LinkedList, 插入 删除时间复杂度O(1),查找时间复杂度O(n);</p>
<p>当弹出最后一个元素后 数据结构自动删除，内存回收。</p>
<p>通常作为异步队列使用，一个线程往里列表放值 另一个线程轮询消费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush lpop  左进右出 队列</span><br><span class="line">rpush rpop 右进右出 栈</span><br></pre></td></tr></table></figure>

<h3 id="慢操作"><a href="#慢操作" class="headerlink" title="慢操作"></a>慢操作</h3><p>取列表中的某个特定值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lindex 相当于get(int index)</span><br><span class="line">ltrim 保留某个区间内的值 可以实现某个定长链表 </span><br><span class="line">    index 可以为负数 倒叙</span><br></pre></td></tr></table></figure>

<h3 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h3><p>Redis列表不是简单的LinkedList 是quicklist 未解决链表指针附加空间太多 用了ziplist结构 用连续内存代替链表指针，多个ziplist用双向指针串联。</p>
<h2 id="hash-（哈希）"><a href="#hash-（哈希）" class="headerlink" title="hash （哈希）"></a>hash （哈希）</h2><p>Redis的字典相当于Java中的HashMap。是无序字典。</p>
<p>是由数组加链表组成的二维结构。第一维数组碰撞时就把碰撞元素用链表串联起来。</p>
<p>redis字典在扩容时使用的事渐进式rehash。 </p>
<ol>
<li>某个时间点ht0需要rehash 分配空间 ht1</li>
<li>在h0上维持索引计数器rehashidx 设置为0</li>
<li>操作数据时 新增在ht1上操作,修改 查找 删除先在ht0上查找 然后同步操作记录到ht1上，h0上的索引计数器+1。</li>
<li>某个时间 h1上所有数据同步完成，索引计数器设置为-1，等待回收，rehash结束。</li>
</ol>
<p>Hash 结构可以单独获取某个属性，字符串会把所有结构一并返回。hash结构存储消耗高于字符串。</p>
<h2 id="set-（集合）"><a href="#set-（集合）" class="headerlink" title="set （集合）"></a>set （集合）</h2><p>Redis 的集合相当于java中的HashSet,内部键值对是无序唯一的。内部实现相当于特殊的字典，字典所有value为null。</p>
<p>set可以用来存储中奖活动用户id，保证不会重复获取用户。</p>
<h2 id="zset-（有序列表）"><a href="#zset-（有序列表）" class="headerlink" title="zset （有序列表）"></a>zset （有序列表）</h2><p>zset 类似java 的sorted 和hashMap的结合体，是一个set 保证value唯一，可以给每个value赋一个score，代表value的排序权重</p>
<p>zset可以存学生id 后面是考试分数，可以根据分数进行排序。</p>
<p>zset用一种叫跳跃列表的数据结构实现。</p>
<h3 id="跳跃列表"><a href="#跳跃列表" class="headerlink" title="跳跃列表"></a>跳跃列表</h3><p>多层级的链表结构，最底层包含所有数据，每往上加一层数据减半，添加查询数据类似树 用的事二分查找定位元素。</p>
<h2 id="容器型数据结构"><a href="#容器型数据结构" class="headerlink" title="容器型数据结构"></a>容器型数据结构</h2><ol>
<li>如果容器不存在就创建一个</li>
<li>如果容器内元素没有了就删除容器</li>
</ol>
<h1 id="redis-可以用来解决什么问题"><a href="#redis-可以用来解决什么问题" class="headerlink" title="redis 可以用来解决什么问题"></a>redis 可以用来解决什么问题</h1><h2 id="redis-分布式锁"><a href="#redis-分布式锁" class="headerlink" title="redis 分布式锁"></a>redis 分布式锁</h2><ol>
<li>setnx 与expire 组合的原子指令</li>
<li>不能解决超时问题</li>
</ol>
<h2 id="redis-队列"><a href="#redis-队列" class="headerlink" title="redis 队列"></a>redis 队列</h2><p> 适用于只有一组消费者，简单有效。</p>
<h3 id="异步消息队列"><a href="#异步消息队列" class="headerlink" title="异步消息队列"></a>异步消息队列</h3><p>利用redis的list 的rpush/lpush lpop/rpop操作队列。</p>
<ol>
<li>接受端增加延迟，使用blpop、brpop阻塞运行。</li>
<li>空闲断开连接时异常处理</li>
<li>redis分布式锁冲突后处理。直接抛出异常，一会重试 加入延迟队列一会重试。</li>
</ol>
<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>利用Redis的zset实现，消息字符串作为zset的value 消息到期处理时间作为score。 多线程轮询找需要处理的任务。zrem保证数据只被一个线程处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Type;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.TypeReference;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class RedisDelayingQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  static class TaskItem&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public String id;</span><br><span class="line">    public T msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; fastjson 序列化对象中存在 generic 类型时，需要使用 TypeReference</span><br><span class="line">  private Type TaskType &#x3D; new TypeReference&lt;TaskItem&lt;T&gt;&gt;() &#123;</span><br><span class="line">  &#125;.getType();</span><br><span class="line">  private Jedis jedis;</span><br><span class="line">  private String queueKey;</span><br><span class="line"></span><br><span class="line">  public RedisDelayingQueue(Jedis jedis, String queueKey) &#123;</span><br><span class="line">    this.jedis &#x3D; jedis;</span><br><span class="line">    this.queueKey &#x3D; queueKey;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void delay(T msg) &#123;</span><br><span class="line">    TaskItem task &#x3D; new TaskItem();</span><br><span class="line">    task.id &#x3D; UUID.randomUUID().toString();</span><br><span class="line">    task.msg &#x3D; msg;</span><br><span class="line">    String s &#x3D; JSON.toJSONString(task);</span><br><span class="line">    jedis.zadd(queueKey, System.currentTimeMillis() + 5000, s); &#x2F;&#x2F; 塞入延时队列 ,5s 后再试</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 分配唯一的 uuid &#x2F;&#x2F; fastjson 序列化</span><br><span class="line"></span><br><span class="line">  public void loop() &#123;</span><br><span class="line">    while (!Thread.interrupted()) &#123;</span><br><span class="line">&#x2F;&#x2F; 只取一条</span><br><span class="line">      Set values &#x3D; jedis.zrangeByScore(queueKey, 0, System.currentTimeMillis(), 0, 1);</span><br><span class="line">      if (values.isEmpty()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(500); &#x2F;&#x2F; 歇会继续</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      String s &#x3D; values.iterator().next();</span><br><span class="line">      if (jedis.zrem(queueKey, s) &gt; 0) &#123;</span><br><span class="line">&#x2F;&#x2F; 抢到了</span><br><span class="line">        TaskItem task &#x3D; JSON.parseObject(s, TaskType);</span><br><span class="line">        this.handleMsg(task.msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handleMsg(T msg) &#123;</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; fastjson 反序列化</span><br><span class="line">    Jedis jedis &#x3D; new Jedis();</span><br><span class="line">    RedisDelayingQueue queue &#x3D; new RedisDelayingQueue&lt;&gt;(jedis, &quot;q-demo&quot;);</span><br><span class="line">    Thread producer &#x3D; new Thread() &#123;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">          queue.delay(&quot;codehole&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread consumer &#x3D; new Thread() &#123;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        queue.loop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">    try &#123;</span><br><span class="line">      producer.join();</span><br><span class="line">      Thread.sleep(6000);</span><br><span class="line">      consumer.interrupt();</span><br><span class="line"></span><br><span class="line">      consumer.join();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>位图就是普通的字符串，bool类型的数据 可以每个占一位。</p>
<p>可以用get/set操作整个位图的内容，也可以用getbit/setbit操作某一位的内容。</p>
<p>Redis 提供位图统计指令bitcount 统一1的个数 和bitpos统计范围内出现第一个0或1。 但是传的参数范围是字节索引，只能是8的倍数。</p>
<p>bitfeld 命令对多个位操作 流处理。最多64位，支持多个子命令。</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>适用范围 不精确去重统计UV访客数之类的 </p>
<p>指令 pfadd pfcount, 找个变量直接用pfadd扔用户id, 然后pfcount取结果就行。 pfmerge可以合并结果。</p>
<p>HyperLogLog占用12k的存储空间 不适合统计单个用户相关的数据，适合大数据量。</p>
<p>Redis 对HyperLogLog的存储进行了优化，采用系数矩阵存储，占用空间很小，数据量变大时才会占用12k的空间。</p>
<h3 id="HyperLogLog实现原理"><a href="#HyperLogLog实现原理" class="headerlink" title="HyperLogLog实现原理"></a>HyperLogLog实现原理</h3><p>基数统计算法 </p>
<p>依据 N个随机数与低连续零位K之间的大致关系为N=2^K</p>
<ol>
<li>找一个BitKeeper变量存K,每次新添加数据更新K值，不存原始数据。</li>
<li>设计一个BitKeeper数组,进行加权评估。多个样本比较准确。</li>
<li>计算倒数平均数（个别异常值对整体影响较小），算出平均K值。</li>
<li>根据之前N=2^K公式算出N的大概值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">public class HyperLogLog &#123;</span><br><span class="line"></span><br><span class="line">  static class BitKeeper &#123;</span><br><span class="line"></span><br><span class="line">    private int maxbits;</span><br><span class="line"></span><br><span class="line">    public void random(long value) &#123;</span><br><span class="line">      int bits &#x3D; lowZeros(value);</span><br><span class="line">      if (bits &gt; this.maxbits) &#123;</span><br><span class="line">        this.maxbits &#x3D; bits;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int lowZeros(long value) &#123;</span><br><span class="line">      int i &#x3D; 1;</span><br><span class="line">      for (; i &lt; 32; i++) &#123;</span><br><span class="line">        if (value &gt;&gt; i &lt;&lt; i !&#x3D; value) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return i - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static class Experiment &#123;</span><br><span class="line"></span><br><span class="line">    private int n;</span><br><span class="line">    private int k;</span><br><span class="line">    private BitKeeper[] keepers;</span><br><span class="line"></span><br><span class="line">    public Experiment(int n) &#123;</span><br><span class="line">      this(n, 1024);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Experiment(int n, int k) &#123;</span><br><span class="line">      this.n &#x3D; n;</span><br><span class="line">      this.k &#x3D; k;</span><br><span class="line">      this.keepers &#x3D; new BitKeeper[k];</span><br><span class="line">      for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line"></span><br><span class="line">        this.keepers[i] &#x3D; new BitKeeper();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void work() &#123;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; this.n; i++) &#123;</span><br><span class="line">        long m &#x3D; ThreadLocalRandom.current().nextLong(1L &lt;&lt; 32);</span><br><span class="line">        BitKeeper keeper &#x3D; keepers[(int) (((m &amp; 0xfff0000) &gt;&gt; 16) % keepers.length)];</span><br><span class="line">        keeper.random(m);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double estimate() &#123;</span><br><span class="line">      double sumbitsInverse &#x3D; 0.0;</span><br><span class="line">      for (BitKeeper keeper : keepers) &#123;</span><br><span class="line">        sumbitsInverse +&#x3D; 1.0 &#x2F; (float) keeper.maxbits;</span><br><span class="line">      &#125;</span><br><span class="line">      double avgBits &#x3D; (float) keepers.length &#x2F; sumbitsInverse;</span><br><span class="line">      return Math.pow(2, avgBits) * this.k;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    for (int i &#x3D; 100000; i &lt; 1000000; i +&#x3D; 100000) &#123;</span><br><span class="line">      Experiment exp &#x3D; new Experiment(i);</span><br><span class="line">      exp.work();</span><br><span class="line">      double est &#x3D; exp.estimate();</span><br><span class="line">      System.out.printf(&quot;%d %.2f %.2f\n&quot;, i, est, Math.abs(est - i) &#x2F; i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="布隆过滤器Bloom-Filter"><a href="#布隆过滤器Bloom-Filter" class="headerlink" title="布隆过滤器Bloom Filter"></a>布隆过滤器Bloom Filter</h2><p>解决问题，头条推送消息，去掉用户已经看过的。</p>
<p>判断某个值一定不存在，或可能存在。</p>
<ol>
<li>存储结构本质是一个长数组，里面存0或1两位数。</li>
<li>通过两种hash算法将某个值映射到数组的两个不同的点 标记为1。</li>
<li>判断传入值的hash映射的两个点是否为都为1 如果都为1则可能存在，有一个不为1则不存在。</li>
</ol>
<p><img src="/images/bloom.svg" loading="lazy"></p>
<h2 id="简单限流"><a href="#简单限流" class="headerlink" title="简单限流"></a>简单限流</h2><p>应用场景，某段时间内的只处理几个请求其余的全部拒绝掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleRateLimiter &#123;</span><br><span class="line"></span><br><span class="line">  private Jedis jedis;</span><br><span class="line"></span><br><span class="line">  public SimpleRateLimiter(Jedis jedis) &#123;</span><br><span class="line">    this.jedis &#x3D; jedis;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean isActionAllowed(String userId, String actionKey, int period, int maxCount) &#123;</span><br><span class="line">    String key &#x3D; String.format(&quot;hist:%s:%s&quot;, userId, actionKey);</span><br><span class="line">    long nowTs &#x3D; System.currentTimeMillis();</span><br><span class="line">    Pipeline pipe &#x3D; jedis.pipelined();</span><br><span class="line">    pipe.multi();</span><br><span class="line">    pipe.zadd(key, nowTs, &quot;&quot; + nowTs);</span><br><span class="line">    pipe.zremrangeByScore(key, 0, nowTs - period * 1000);</span><br><span class="line">    Response&lt;Long&gt; count &#x3D; pipe.zcard(key);</span><br><span class="line">    pipe.expire(key, period + 1);</span><br><span class="line">      pipe.exec();</span><br><span class="line">    try &#123;</span><br><span class="line">      pipe.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return count.get() &lt;&#x3D; maxCount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Jedis jedis &#x3D; new Jedis();</span><br><span class="line">    SimpleRateLimiter limiter &#x3D; new SimpleRateLimiter(jedis);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">      System.out.println(limiter.isActionAllowed(&quot;laoqian&quot;, &quot;reply&quot;, 60, 5));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="漏斗限流-redis-cell"><a href="#漏斗限流-redis-cell" class="headerlink" title="漏斗限流 redis-cell"></a>漏斗限流 redis-cell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl.throttle laoqian:reply 15 30 60</span><br></pre></td></tr></table></figure>

<h2 id="GeoHash-地理位置排序"><a href="#GeoHash-地理位置排序" class="headerlink" title="GeoHash 地理位置排序"></a>GeoHash 地理位置排序</h2><p>地理位置排序，将二维经纬度映射到一维整数，将所有元素挂载到一条线上。</p>
<p>二刀法 一个正方形切成4个小正方形 可以标记为 00，01，10，11<br>在切第一个小正方形 0000 0001 0010 0011 每个分成4个二进制整数。真实算法还会有其他刀法，最终编码出的整数也不一样。</p>
<p>单个key中的数据量不应超过1M</p>
<p>六个命令 geoadd geolist geopos geohash georadiusbymember georadius</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi (integer) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km &quot;10.5501&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin meituan km &quot;1.3878&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin jd km &quot;24.2739&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin xiaomi km &quot;12.9606&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin juejin km &quot;0.0000&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin 1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">2) &quot;39.99679348858259686&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company ireader 1) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">2) &quot;39.90540918662494363&quot; </span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin ireader 1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">2) &quot;39.99679348858259686&quot; 2) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">2) &quot;39.90540918662494363&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geohash company ireader 1) &quot;wx4g52e1ce0&quot;</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin 1) &quot;wx4gd94yjn0&quot;</span><br><span class="line"></span><br><span class="line"># 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc 1) &quot;ireader&quot;</span><br><span class="line">2) &quot;juejin&quot;</span><br><span class="line">3) &quot;meituan&quot;</span><br><span class="line"># 范围 20 公里以内最多 3 个元素按距离倒排</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 desc 1) &quot;jd&quot;</span><br><span class="line">2) &quot;meituan&quot;</span><br><span class="line">3) &quot;juejin&quot;</span><br><span class="line"># 三个可选参数 withcoord withdist withhash 用来携带附加参数</span><br><span class="line"># withdist 很有用，它可以用来显示距离</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc 1) 1) &quot;ireader&quot;</span><br><span class="line">2) &quot;0.0000&quot;</span><br><span class="line">3) (integer) 4069886008361398 4) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">2) &quot;39.90540918662494363&quot; 2) 1) &quot;juejin&quot;</span><br><span class="line">2) &quot;10.5501&quot;</span><br><span class="line">3) (integer) 4069887154388167 4) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">2) &quot;39.99679348858259686&quot; 3) 1) &quot;meituan&quot;</span><br><span class="line">2) &quot;11.5748&quot;</span><br><span class="line">3) (integer) 4069887179083478 4) 1) &quot;116.48903220891952515&quot;</span><br><span class="line">2) &quot;40.00766997707732031&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; georadius company 116.514202 39.905409 20 km withdist count 3 asc 1) 1) &quot;ireader&quot;</span><br><span class="line">2) &quot;0.0000&quot; 2) 1) &quot;juejin&quot;</span><br><span class="line">2) &quot;10.5501&quot; 3) 1) &quot;meituan&quot;</span><br><span class="line">2) &quot;11.5748&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Scan-找出特定前缀的key列表"><a href="#Scan-找出特定前缀的key列表" class="headerlink" title="Scan 找出特定前缀的key列表"></a>Scan 找出特定前缀的key列表</h2><ol>
<li>指令 keys [regular] </li>
</ol>
<p>缺点:</p>
<ol>
<li>没有分页 </li>
<li>遍历算法 时间复杂度O(n) redis单线程 其他指令会延后</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set codehole1 a OK</span><br><span class="line">127.0.0.1:6379&gt; set codehole2 b OK</span><br><span class="line">127.0.0.1:6379&gt; set codehole3 c OK</span><br><span class="line">127.0.0.1:6379&gt; set code1hole a OK</span><br><span class="line">127.0.0.1:6379&gt; set code2hole b OK</span><br><span class="line">127.0.0.1:6379&gt; set code3hole b OK</span><br><span class="line">127.0.0.1:6379&gt; keys * </span><br><span class="line">1) &quot;codehole1&quot;</span><br><span class="line">2) &quot;code3hole&quot;</span><br><span class="line">3) &quot;codehole3&quot;</span><br><span class="line">4) &quot;code2hole&quot;</span><br><span class="line">5) &quot;codehole2&quot;</span><br><span class="line">6) &quot;code1hole&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys codehole* </span><br><span class="line">1) &quot;codehole1&quot;</span><br><span class="line">2) &quot;codehole3&quot;</span><br><span class="line">3) &quot;codehole2&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys code*hole </span><br><span class="line">1) &quot;code3hole&quot;</span><br><span class="line">2) &quot;code2hole&quot;</span><br><span class="line">3) &quot;code1hole&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>scan </li>
</ol>
<p>scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三<br>个是遍历的 limit hint。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为<br>下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。</p>
<p>1、复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;<br>2、提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hint，返回的 结果可多可少;<br>3、同 keys 一样，它也提供模式匹配功能;<br>4、服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;<br>5、返回的结果可能会有重复，需要客户端去重复，这点非常重要;<br>6、遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;<br>7、单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match key99* count 1000</span><br><span class="line">1) &quot;13976&quot;</span><br><span class="line">2)1) &quot;key9911&quot; </span><br><span class="line">2) &quot;key9974&quot; </span><br><span class="line">3) &quot;key9994&quot; </span><br><span class="line">4) &quot;key9910&quot; </span><br><span class="line">5) &quot;key9907&quot; </span><br><span class="line">6) &quot;key9989&quot; </span><br><span class="line">7) &quot;key9971&quot; </span><br><span class="line">8) &quot;key99&quot; </span><br><span class="line">9) &quot;key9966&quot;</span><br><span class="line">10) &quot;key992&quot; </span><br><span class="line">11) &quot;key9903&quot; </span><br><span class="line">12) &quot;key9905&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 13976 match key99* count 1000 </span><br><span class="line">1) &quot;1996&quot;</span><br><span class="line">2)1) &quot;key9982&quot; </span><br><span class="line">2) &quot;key9997&quot; </span><br><span class="line">3) &quot;key9963&quot; </span><br><span class="line">4) &quot;key996&quot; </span><br><span class="line">5) &quot;key9912&quot; </span><br><span class="line">6) &quot;key9999&quot; </span><br><span class="line">7) &quot;key9921&quot; </span><br><span class="line">8) &quot;key994&quot; </span><br><span class="line">9) &quot;key9956&quot;10) </span><br><span class="line">&quot;key9919&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 1996 match key99* count 1000 </span><br><span class="line">1) &quot;12594&quot;</span><br><span class="line">2) 1) &quot;key9939&quot;</span><br><span class="line">2) &quot;key9941&quot; </span><br><span class="line">3) &quot;key9967&quot; </span><br><span class="line">4) &quot;key9938&quot; </span><br><span class="line">5) &quot;key9906&quot; </span><br><span class="line">6) &quot;key999&quot; </span><br><span class="line">7) &quot;key9909&quot; </span><br><span class="line">8) &quot;key9933&quot;</span><br><span class="line"> 9) &quot;key9992&quot;</span><br><span class="line">......</span><br><span class="line">127.0.0.1:6379&gt; scan 11687 match key99* count 1000 </span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2)1) &quot;key9969&quot; </span><br><span class="line">2) &quot;key998&quot; </span><br><span class="line">3) &quot;key9986&quot; </span><br><span class="line">4) &quot;key9968&quot;</span><br><span class="line"> 5) &quot;key9965&quot; </span><br><span class="line"> 6) &quot;key9990&quot; </span><br><span class="line"> 7) &quot;key9915&quot;</span><br><span class="line">  8) &quot;key9928&quot; </span><br><span class="line">  9) &quot;key9908&quot;</span><br><span class="line">  10) &quot;key9929&quot; </span><br><span class="line">  11) &quot;key9944</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p> <img src="/images/103.png" loading="lazy"></p>
<p> redis所有key都存在一个很大的字典中，是数组加链表的结构。</p>
<p> scan的游标是一维数组的索引。</p>
<p> scan的遍历是高位进位加法。</p>
<p> hash底层就是字典，set也是特殊的字典，都可以用scan遍历</p>
<p> redis字典扩容 加一位高位 从一个槽变成两个。</p>
<p>  <img src="/images/104.png" loading="lazy"></p>
<p> 高位进位加法从左边加 进位往右边移动，与普通加法正好相反。</p>
<p> 扩容后的字典，用高位加法遍历是相邻的，可以避免重复遍历</p>
<p> <img src="/images/105.png" loading="lazy"></p>
<h3 id="避免使用大key"><a href="#避免使用大key" class="headerlink" title="避免使用大key"></a>避免使用大key</h3><p>有时候会因为业务人员使用不当，在 Redis 实例中会形成很大的对象，<br>比如一个很大的 hash，一个很大的 zset 这都是经常出现的。这样的对象对 Redis 的集群数据迁移带来了很 大的问题，因为在集群环境下，<br>如果某个 key 太大，会数据导致迁移卡顿。另外在内存分配 上，如果一个 key 太大，那么当它需要扩容时，会一次性申请更大的一块内存，<br>这也会导致 卡顿。如果这个大 key 被删除，内存会一次性回收，卡顿现象会再一次产生。</p>
<h4 id="定位大key"><a href="#定位大key" class="headerlink" title="定位大key"></a>定位大key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7001 –-bigkeys</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7001 –-bigkeys -i 0.1</span><br></pre></td></tr></table></figure>

<h1 id="redis-IO模型"><a href="#redis-IO模型" class="headerlink" title="redis IO模型"></a>redis IO模型</h1><p>redis是单线程</p>
<p>redis所有数据存在内存中所以很快</p>
<p>多路复用 select系列的事件轮询API 非阻塞IO</p>
<h2 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h2><p>IO在计算机中指Input/Output，由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>类似于读书，一个人可以看多本书，但是每次只能看一本，而且也不可能一次看完一本书，至于每次到底看几页，那和看书的时间长度与人看书的效率有关。</p>
<h2 id="事件轮询-多路复用"><a href="#事件轮询-多路复用" class="headerlink" title="事件轮询 (多路复用)"></a>事件轮询 (多路复用)</h2><p>和看书一样，如果要求你写读后感，就是输出一个io操作的结果。肯定要等到这本书都看完才行。<br>而现在又需要你写好多本书的读后感的话，就会出现一个人在那里问 A书的读后感写了吗，B书的读后感写了吗… 一会一次的在那催。</p>
<h2 id="指令队列"><a href="#指令队列" class="headerlink" title="指令队列"></a>指令队列</h2><p>客户端的指令过来，单线程不能全部执行，肯定要放到队列里，先进先出</p>
<h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>处理完的结果不是直接返回而是放到队列里，供轮询时直接调用返回结果事件</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h1 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h1><p>Redis 的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。<br>所以即使 Redis 使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis 将所有数据都放在内存，<br>用一个单线程对外提供服务，单个节点在跑满一个 CPU 核心的情 况下可以达到了 10w/s 的超高 QPS。</p>
<h2 id="RESP-Redis-Serialization-Protocol-Redis序列化协议"><a href="#RESP-Redis-Serialization-Protocol-Redis序列化协议" class="headerlink" title="RESP(Redis Serialization Protocol)Redis序列化协议"></a>RESP(Redis Serialization Protocol)Redis序列化协议</h2><p>文本协议</p>
<p>将传输的结构数据分成5种最小单元 单元结束事统一加回车换行符<code>/r/n</code></p>
<ol>
<li>单行字符串 以<code>+</code>号开头  </li>
<li>多行字符串 以<code>$</code>开头 后跟字符串长度</li>
<li>整数字值 以<code>:</code>开头 后跟字符串形式</li>
<li>错误消息 以<code>-</code>开头</li>
<li>数组 以<code>*</code>号开头 后跟数组长度</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1. hellow world</span><br><span class="line"></span><br><span class="line">+hello world\r\n</span><br><span class="line"></span><br><span class="line">2. hellow world</span><br><span class="line"></span><br><span class="line">$11&#x2F;r&#x2F;nhello world&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">3. 1024</span><br><span class="line"></span><br><span class="line">:1024&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">4. 参数类型错误</span><br><span class="line"></span><br><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line"></span><br><span class="line">5. [&quot;hello&quot;,&quot;world&quot;]</span><br><span class="line"></span><br><span class="line">*3&#x2F;r&#x2F;n+hello&#x2F;r&#x2F;n+world&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">6. NULL</span><br><span class="line"></span><br><span class="line">$-1&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">7. &quot;&quot;</span><br><span class="line"></span><br><span class="line">$0&#x2F;r&#x2F;n&#x2F;r&#x2F;n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="客户端-gt-服务器"><a href="#客户端-gt-服务器" class="headerlink" title="客户端-&gt;服务器"></a>客户端-&gt;服务器</h2><p>客户端到服务器只有一种格式就是<code>多行字符串数组</code></p>
<p>set name kwkw</p>
<p>序列化后 *3/r/n$3/r/nser/r/n$4/r/nname/r/n$4/r/nkwkw/r/n</p>
<h2 id="服务器-gt-客户端"><a href="#服务器-gt-客户端" class="headerlink" title="服务器-&gt;客户端"></a>服务器-&gt;客户端</h2><p>上述5中基本数据结构的组合</p>
<h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><p>redis数据存在内存中，为保证数据不丢失需要引入redis持久化机制</p>
<h2 id="快照-一次性全量备份"><a href="#快照-一次性全量备份" class="headerlink" title="快照 一次性全量备份"></a>快照 一次性全量备份</h2><p>快照是内存数据的二进制序列化，在存储上非常紧凑。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>前提是redis是单线程的程序，这个线程负责多客户端的并发读写操作。在并发操作的同时还需要进行文件io操作备份快照。</p>
<p>要求是不能影响线上服务，必须进行本地快照，持久化的同时数据结构还会变。</p>
<p>redis使用操作系统的多进程COW（copy on write）来实现快照持久化。</p>
<p>redis在持久化时候回调用glibc的fork函数创建一个子进程。持久化操作完全交给子进程。<br>创建子进程之处，由于操作系统的优化，子进程和父进程共享内存中带代码段和数据段。内存几乎不变。<br>子进程负责持久化工作，父进程负责业务服务。<br>子进程负责写入内存里面的数据段不变。而父进程的业务数据会改内存的数据段。<br>而当改变的时候操作系统会首先看有没有别的进程在使用当前数据段，如果有那就复制一份改自己复制出的这份。这就是操作系统的COW机制。<br>随着父线程的修改，共享内存会越来越多，但是最多不会超过开启进程前的二倍。</p>
<h2 id="AOF重写-连续增量备份"><a href="#AOF重写-连续增量备份" class="headerlink" title="AOF重写 连续增量备份"></a>AOF重写 连续增量备份</h2><p>AOF日志记录是内存数据修改的指令记录文本。</p>
<p>AOF日志存储是redis服务器的顺序指令序列，只记录对内存进行修改的指令记录。</p>
<p>Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行瘦身。<br>就是开辟一个子进程对内存进行遍历转换成redis指令序列化到另一个AOC文件，在将序列化这段时间内的指令追加到新的AOC文件上。</p>
<p>AOC是日志文件，指令是存在内存中，如果指令没有同步到文件之前就宕机了，就会发生日志文件不全，数据丢失。</p>
<p>Linux 的 glibc 提供了 fsync(int fd)函数能强制将缓存刷到磁盘。</p>
<p>redis提供了两种机制 </p>
<ol>
<li>实时同步每一条指令刷一次 缺点非常慢，数据一定完整。</li>
<li>不同步 让操作系统决定什么时候同步。 缺点 数据不一定完整。</li>
</ol>
<p>而使用redis为的就是追求高性能，在同时尽可能保证数据的准确性 所以线上设置1s一次fsync。</p>
<p><code>redis不能保证数据完全不丢失</code></p>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>快照是通过开启子进程的方式进行的，是个比较耗时的操作。</p>
<ol>
<li>遍历所有内存大块写内存耗费系统资源。</li>
<li>AOC的fsync操作是耗时的io操作，会增加系统负担。</li>
</ol>
<p>所以用到redis集群时为了追求性能主库不会持久化数据，要在从库上做持久化，从库需要考虑的问题就是与主库的数据同步，加一个从库保证系统数据不丢失。</p>
<h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>把rdb与AOC日志文件放到一起，AOC日志文件只存储持久化过程中的数据。读数据时候先读rdb在从新放AOC增量。</p>
<h1 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h1><p>redis管道是由redis客户端提供了 和服务器没关系</p>
<p>封装了多次http请求的request和response，统一处理， 和服务器的指令队列和响应队列差不多。只是改到了客户端。</p>
<h1 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h1><p>只支持隔离性 多条操作如果有一条失败其他会顺序执行<br>discard(丢弃)命令 在事务提交前 可以取消掉操作结果。<br>当执行redis事务时，用管道操作 pipeline</p>
<p>redis 不支持事务回滚，只能在事务提交前用discard命令取消掉当前提交，需要手动控制。</p>
<h1 id="redis-小对象压缩"><a href="#redis-小对象压缩" class="headerlink" title="redis 小对象压缩"></a>redis 小对象压缩</h1><h2 id="小对象压缩存储-ziplist"><a href="#小对象压缩存储-ziplist" class="headerlink" title="小对象压缩存储 ziplist"></a>小对象压缩存储 ziplist</h2><p>如果redis内部管理的数据结构很小 就会使用紧凑存储结构压缩储存。</p>
<p>如果存储的数据少于某个临界点，那么就会存在一个叫ziplist的字节数组中。 大于某个临界点就会升级为标准结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hash-max-zipmap-entries 512 # hash 的元素个数超过 512 就必须用标准结构存储 </span><br><span class="line">hash-max-zipmap-value 64 # hash 的任意元素的 key&#x2F;value 的长度超过 64 就必须用标准结构存储 </span><br><span class="line">list-max-ziplist-entries 512 # list 的元素个数超过 512 就必须用标准结构存储</span><br><span class="line">list-max-ziplist-value 64 # list 的任意元素的长度超过 64 就必须用标准结构存储</span><br><span class="line">zset-max-ziplist-entries 128 # zset 的元素个数超过 128 就必须用标准结构存储</span><br><span class="line">zset-max-ziplist-value 64 # zset 的任意元素的长度超过 64 就必须用标准结构存储</span><br><span class="line">set-max-intset-entries 512 # set 的整数元素个数超过 512 就必须用标准结构存储</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="redis的内存回收机制"><a href="#redis的内存回收机制" class="headerlink" title="redis的内存回收机制"></a>redis的内存回收机制</h2><p>删除key后，value分配的内存并没有直接回收，而是后来的数直接用，flushdb时才会回收内存。</p>
<p>redis内存分配直接用第三方分配库实现 jemalloc(facebook) tcmalloc(google),libc</p>
<h1 id="redis主从同步"><a href="#redis主从同步" class="headerlink" title="redis主从同步"></a>redis主从同步</h1><h2 id="cap原则"><a href="#cap原则" class="headerlink" title="cap原则"></a>cap原则</h2><p>分布式系统设计理论</p>
<p>网络分区发生时 一致性和可用性不能两全。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>redis主从系统数据异步同步，只满足最终一致性。</p>
<h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p>redis支持主从同步</p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>redis同步的是指令流，主节点会将对自己状态产生修改行影响的指令记录在本地buffer中，然后异步将buffer同步到从节点。<br>由于内存中的buffer长度有限，redis内存中的buffer是一个定长的环形数组，如果buffer满了就会覆盖之前的数据，覆盖后的数据会丢失。</p>
<h2 id="快照同步"><a href="#快照同步" class="headerlink" title="快照同步"></a>快照同步</h2><p>首先主库进行一次bgsave将内存中的数据快照进磁盘文件中，磁盘文件同步到从库，从库直接load rdb文件，然后增量同步主库的buffer.<br>如果buffer内存不够，依然会丢失数据</p>
<p>在增加从节点时必须先进行一次快照同步之后才能进行增量同步。</p>
<h2 id="无盘复制"><a href="#无盘复制" class="headerlink" title="无盘复制"></a>无盘复制</h2><p>快照时会发生很重的io操作，所以主库省略写文件过程，直接通过socket发给从库，从库直接写入。</p>
<h2 id="wait指令"><a href="#wait指令" class="headerlink" title="wait指令"></a>wait指令</h2><p>使某个操作同步执行到从库，wait 1[从库的数量] 0[最多等待时间，0表示无限]。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; set key value </span><br><span class="line">OK</span><br><span class="line">&gt; wait 1 0 </span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="redis-集群策略"><a href="#redis-集群策略" class="headerlink" title="redis 集群策略"></a>redis 集群策略</h1><h2 id="Redis-Sentinel-哨兵"><a href="#Redis-Sentinel-哨兵" class="headerlink" title="Redis Sentinel(哨兵)"></a>Redis Sentinel(哨兵)</h2><ol>
<li>客户端先与sentinel节点通信获取master节点的地址。</li>
<li>客户端访问master节点。</li>
<li>如果master节点down掉sentinel选举出新的master。</li>
<li>如果原来的master节点恢复会变成slave节点。</li>
</ol>
<p>在master节点挂掉到选举出新的master节点之前会丢失一部分数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1 </span><br><span class="line">min-slaves-max-lag 10</span><br><span class="line">第一个参数表示主节点必须至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。</span><br><span class="line">第二个参数控制的，它的单位是秒，表示如 果 10s 没有收到从节点的反馈，就意味着从节点同步不正常，要么网络断开了，要么一直没有给反馈。</span><br><span class="line"></span><br></pre></td></tr></table></figure>








</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay.jpg"><img loading="lazy" src="/dongkw.github.io/images/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay.jpg"><img loading="lazy" src="/dongkw.github.io/images/wechatpay.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>dongkw</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://dongkw.github.io/2020/03/20/redis/" title="redis">http://dongkw.github.io/2020/03/20/redis/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless stating additionally.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/dongkw.github.io/2020/03/25/gradle%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/" rel="prev" title="gradle自定义插件（初见）"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">gradle自定义插件（初见）</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/dongkw.github.io/2020/03/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="next" title="jvm学习《深入理解java虚拟机》读书笔记（2）垃圾回收"><span class="post-nav-text">jvm学习《深入理解java虚拟机》读书笔记（2）垃圾回收</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/dongkw/dongkw.github.io/issues?q=is:issue+redis">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> dongkw</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.2.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.0.0</span></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="Total Visitors"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/dongkw.github.io/js/utils.js"></script><script defer src="/dongkw.github.io/js/hexo-theme-yun.js"></script></body></html>